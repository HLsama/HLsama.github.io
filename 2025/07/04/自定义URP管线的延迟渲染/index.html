
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <title>自定义URP管线的延迟渲染 | 枫雪のHome</title>
    <meta name="author" content="枫雪" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>枫雪のHOME</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于我</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;归档</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;枫雪のHOME</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于我</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">归档</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>自定义URP管线的延迟渲染</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/7/4
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>这是一段代码测试</p>
<span id="more"></span>

<p>一下为测试代码</p>
<pre><code class="language-c">//Include
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
//引用关于BitTex相关的库，来拿到摄象机传来的图
#include &quot;Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl&quot;

//Texture&amp; Samplers
float4 _BlitTexture_TexelSize;
TEXTURE2D_X_FLOAT(_CameraDepthTexture);
TEXTURE2D_X_FLOAT(_CameraNormalsTexture);
SAMPLER(sampler_CameraNormalsTexture);
SAMPLER(sampler_CameraDepthTexture);
Texture2D _HierarchicalZBufferTexture;

// Params
//重构世界坐标相关参数
float4 _CameraViewTopLeftCorner;
float4 _CameraViewXExtent;
float4 _CameraViewYExtent;
float4 _ProjectionParams2;
//光线步进相关参数
float _Stride;//步幅
float _Thickness;//厚度
float _StepCount;//最大步进次数
float _MaxDistance;//最大步进长度
float4 _SourceSize;//原图尺寸
float _MipCount2;
//HiZ相关参数
float _HierarchicalZBufferTextureFromMipLevel;
float _HierarchicalZBufferTextureToMipLevel;
float _MaxHierarchicalZBufferTextureMipLevel;


//结构体
struct appdata
&#123;
    uint vertexID : SV_VertexID;
    UNITY_VERTEX_INPUT_INSTANCE_ID
&#125;;

struct v2f
&#123;
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;
&#125;;

//计算相对于摄象机的偏移值
float3 ReconstructViewPos(float2 uv,float Depth)
&#123;
    uv.y = 1-uv.y;

    float zSize = Depth*_ProjectionParams2.x;
    float3 viewPos = _CameraViewTopLeftCorner.xyz+_CameraViewXExtent*uv.x+_CameraViewYExtent*uv.y;
    return zSize*viewPos;
&#125;

//每步步进的uv与深度
void ReconstructUVAndDepth(float3 wpos, out float2 uv, out float depth)
&#123;  
    float4 cpos = mul(UNITY_MATRIX_VP, wpos);  
    uv = float2(cpos.x, cpos.y * _ProjectionParams.x) / cpos.w * 0.5 + 0.5;  
    depth = cpos.w;  
&#125;

//变换坐标到屏幕空间
float4 TransformViewToHScreen(float3 vpos, float2 screenSize)
&#123;  
    float4 cpos = mul(UNITY_MATRIX_P, vpos);  
    cpos.xy = float2(cpos.x, cpos.y * _ProjectionParams.x) * 0.5 + 0.5 * cpos.w;  
    cpos.xy *= screenSize;  
    return cpos;  
&#125;  
//交换数据
void swap(inout float v0, inout float v1)
&#123;  
    float temp = v0;  
    v0 = v1;    
    v1 = temp;
&#125;
//获取源图
float4 GetSource(float2 uv)
&#123;
    float4 col = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);
    return col;
&#125;
//深度图
float SampleSceneDepth(float2 uv)
&#123;
    float Depth = SAMPLE_TEXTURE2D_X(_CameraDepthTexture,sampler_CameraDepthTexture,uv).r;
    return Depth;
&#125;
float4 GetHiZSoure(float2 uv,float2 offset = 0,float mipLevel = 0)
&#123;
    offset *= _SourceSize.zw;
    return SAMPLE_TEXTURE2D_X_LOD(_BlitTexture, sampler_LinearRepeat, uv + offset, mipLevel);
&#125;
// jitter dither map
static float dither[16] = &#123;
    0.0, 0.5, 0.125, 0.625,
    0.75, 0.25, 0.875, 0.375,
    0.187, 0.687, 0.0625, 0.562,
    0.937, 0.437, 0.812, 0.312
&#125;;
//通用顶点着色器
v2f vert (appdata v)
&#123;
    v2f o;
    o.vertex = GetFullScreenTriangleVertexPosition(v.vertexID);
    //参考了官方bloom的uv拿法
    float2 uv = GetFullScreenTriangleTexCoord(v.vertexID);
    o.uv= uv * _BlitScaleBias.xy + _BlitScaleBias.zw;
    return o;
&#125;

//SSR用片源着色器
float4 SSRfrag (v2f i) : SV_Target
&#123;
    //采样数据
    float2 uv = UnityStereoTransformScreenSpaceTex(i.uv);
    float Depth = SAMPLE_TEXTURE2D_X(_CameraDepthTexture,sampler_CameraDepthTexture,uv).r;
    Depth = LinearEyeDepth(Depth,_ZBufferParams);
    float3 Normal = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture,sampler_CameraNormalsTexture,uv);
    float4 col = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);//采样前屏幕纹理
    //深度图还原世界坐标
    float3 viewPos = ReconstructViewPos(uv,Depth);
    float3 posWS = _WorldSpaceCameraPos+viewPos;
    //视空间反射方向
    float3 vDir = normalize(viewPos);
    float3 vrDir = TransformWorldToViewDir(normalize(reflect(vDir,Normal)));

    //视空间的光线步进
    /*UNITY_LOOP
    for(int i=0;i&lt;100;i++)
    &#123;
        float3 viewPos2 = viewPos+vrDir*i*_Stride;
        float2 uv2;  
        float stepDepth;  
        ReconstructUVAndDepth(viewPos2, uv2, stepDepth);
        float stepRawDepth = SAMPLE_TEXTURE2D_X(_CameraDepthTexture,sampler_CameraDepthTexture,uv2).r;  
        float stepSurfaceDepth = LinearEyeDepth(stepRawDepth, _ZBufferParams);  
        if (stepSurfaceDepth &lt; stepDepth &amp;&amp; stepDepth &lt; stepSurfaceDepth + _Thickness)
            return SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv2);  
    &#125;
    return float4(0,0,0,1);*/



    
    //屏幕空间的光线步进（DDA画线法）
    //首先规定最大步进长度（自定义最大步进终点，这样才能DDA画线）
    float magnitude = _MaxDistance;
    float3 startView = TransformWorldToView(posWS);//视空间起点
    float end = startView.z + vrDir.z * magnitude;
    if (end &gt; -_ProjectionParams.y)
        magnitude = (-_ProjectionParams.y - startView.z) / vrDir.z;
    float3 endView = startView+vrDir*magnitude;//视空间终点
    float4 startHScreen = TransformViewToHScreen(startView, _SourceSize.xy);//屏幕空间起点
    float4 endHScreen = TransformViewToHScreen(endView, _SourceSize.xy);//屏幕空间终点
    //1/k
    float startK = 1.0/startHScreen.w;
    float endK = 1.0/endHScreen.w;
    //与之前的屏幕坐标有什么区别？？？
    float2 startScreen = startHScreen.xy*startK;
    float2 endScreen = endHScreen.xy * endK;

    //齐次除法视坐标？？？？
    float3 startQ = startView*startK;
    float3 endQ = endView*endK;
    //斜率切换xy
    float2 diff = endScreen-startScreen;
    bool permute = false;
    if(abs(diff.x)&lt;abs(diff.y))
    &#123;
        permute = true;
        diff = diff.yx;
        startScreen = startScreen.yx;
        endScreen = endScreen.yx;
    &#125;
    //计算屏幕坐标，齐次坐标，inverse-w的线性增量
    float dir = sign(diff.x);
    float invdx = dir/diff.x;
    float2 dp = float2(dir,invdx*diff.y);//步进方向
    float3 dq = (endQ-startQ)*invdx;
    float dk = (endK-startK)*invdx;

    dp *=_Stride;//步进方向*距离
    dq *=_Stride;
    dk *=_Stride;
    //缓存当前深度和位置(为什么这些都是同一深度）
    float rayZMin = startView.z;  
    float rayZMax = startView.z;  
    float preZ = startView.z;

    float2 P = startScreen;
    float3 Q = startQ;
    float K = startK;
    
    end = endScreen.x * dir;
    //屏幕空间光线步进
    UNITY_LOOP
    for (int i =0;i&lt;_StepCount&amp;&amp;P.x*dir&lt;=end;i++)
    &#123;
        //步进
        P +=dp;//屏幕空间步进一个像素
        Q.z +=dq.z;//深度步进
        K +=dk;//K值也跟着增加
        //步进前后两点的深度
        rayZMin = preZ;
        rayZMax = (dq.z*0.5+Q.z)/(dk*0.5+K);
        preZ = rayZMax;
        if(rayZMin&gt;rayZMax)
        &#123;
            swap(rayZMin, rayZMax);  
        &#125;
        //得到交点UV
        float2 hitUV = permute?P.yx:P;
        hitUV *=_SourceSize.zw;
        if(any(hitUV&lt;0.0)||any(hitUV&gt;1.0))
        &#123;
            return float4(col);
        &#125;
        float surfaceDepth = -LinearEyeDepth(SampleSceneDepth(hitUV), _ZBufferParams);
        bool isBehind = (rayZMin + 0.1 &lt;= surfaceDepth);//防止步进步数过小，自反射；
        bool intersecting = isBehind &amp;&amp; (rayZMax &gt;= surfaceDepth - _Thickness);
        if (intersecting)
        &#123;
            return GetSource(hitUV)+col; 
        &#125;
    &#125;
    return float4(col);
&#125;
//用HiZ优化的SSR
float4 HiZSSRfrag (v2f i) : SV_Target
&#123;
    //采样数据
    float2 uv = UnityStereoTransformScreenSpaceTex(i.uv);
    float Depth = SAMPLE_TEXTURE2D_X(_CameraDepthTexture,sampler_CameraDepthTexture,uv).r;
    Depth = LinearEyeDepth(Depth,_ZBufferParams);
    float3 Normal = SAMPLE_TEXTURE2D_X(_CameraNormalsTexture,sampler_CameraNormalsTexture,uv);
    float4 col = SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv);//采样前屏幕纹理
    //深度图还原世界坐标
    float3 viewPos = ReconstructViewPos(uv,Depth);
    float3 posWS = _WorldSpaceCameraPos+viewPos;
    //视空间反射方向
    float3 vDir = normalize(viewPos);
    float3 vrDir = TransformWorldToViewDir(normalize(reflect(vDir,Normal)));

    //视空间的光线步进
    /*UNITY_LOOP
    for(int i=0;i&lt;100;i++)
    &#123;
        float3 viewPos2 = viewPos+vrDir*i*_Stride;
        float2 uv2;  
        float stepDepth;  
        ReconstructUVAndDepth(viewPos2, uv2, stepDepth);
        float stepRawDepth = SAMPLE_TEXTURE2D_X(_CameraDepthTexture,sampler_CameraDepthTexture,uv2).r;  
        float stepSurfaceDepth = LinearEyeDepth(stepRawDepth, _ZBufferParams);  
        if (stepSurfaceDepth &lt; stepDepth &amp;&amp; stepDepth &lt; stepSurfaceDepth + _Thickness)
            return SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv2);  
    &#125;
    return float4(0,0,0,1);*/



    
    //屏幕空间的光线步进（DDA画线法）
    //首先规定最大步进长度（自定义最大步进终点，这样才能DDA画线）
    float magnitude = _MaxDistance;
    float3 startView = TransformWorldToView(posWS);//视空间起点
    float end = startView.z + vrDir.z * magnitude;
    if (end &gt; -_ProjectionParams.y)
        magnitude = (-_ProjectionParams.y - startView.z) / vrDir.z;
    float3 endView = startView+vrDir*magnitude;//视空间终点
    float4 startHScreen = TransformViewToHScreen(startView, _SourceSize.xy);//屏幕空间起点
    float4 endHScreen = TransformViewToHScreen(endView, _SourceSize.xy);//屏幕空间终点
    //1/k
    float startK = 1.0/startHScreen.w;
    float endK = 1.0/endHScreen.w;
    //与之前的屏幕坐标有什么区别？？？
    float2 startScreen = startHScreen.xy*startK;
    float2 endScreen = endHScreen.xy * endK;

    //齐次除法视坐标？？？？
    float3 startQ = startView*startK;
    float3 endQ = endView*endK;
    //斜率切换xy
    float2 diff = endScreen-startScreen;
    bool permute = false;
    if(abs(diff.x)&lt;abs(diff.y))
    &#123;
        permute = true;
        diff = diff.yx;
        startScreen = startScreen.yx;
        endScreen = endScreen.yx;
    &#125;
    //计算屏幕坐标，齐次坐标，inverse-w的线性增量
    float dir = sign(diff.x);
    float invdx = dir/diff.x;
    float2 dp = float2(dir,invdx*diff.y);//步进方向
    float3 dq = (endQ-startQ)*invdx;
    float dk = (endK-startK)*invdx;

    dp *=_Stride;//步进方向*距离
    dq *=_Stride;
    dk *=_Stride;
    //缓存当前深度和位置(为什么这些都是同一深度）
    float rayZMin = startView.z;  
    float rayZMax = startView.z;  
    float preZ = startView.z;

    int mipLevel = 0.0;
    //float2 hitUV = 0.0;

    float2 P = startScreen;
    float3 Q = startQ;
    float K = startK;
    /*// Binary抖动

    float2 ditherUV = fmod(P, 4);
    float jitter = lerp(1, dither[ditherUV.x * 3 + ditherUV.y],float3(0.2,0,1));
    P += dp * jitter;
    Q += dq * jitter;
    K += dk * jitter;*/
    //屏幕空间光线步进
    UNITY_LOOP
    for (int i =0;i&lt;_StepCount;i++)
    &#123;
        //步进
        P +=dp*exp2(mipLevel);//屏幕空间步进一个像素
        Q +=dq*exp2(mipLevel);//深度步进
        K +=dk*exp2(mipLevel);//K值也跟着增加
        //步进前后两点的深度
        rayZMin = preZ;
        rayZMax = (dq.z*exp2(mipLevel)*0.5+Q.z)/(dk*exp2(mipLevel)*0.5+K);
        preZ = rayZMax;
        if(rayZMin&gt;rayZMax)
        &#123;
            swap(rayZMin, rayZMax);  
        &#125;
        //得到交点UV
        float2 hitUV = permute?P.yx:P;
        hitUV *=_SourceSize.zw;
        if(any(hitUV&lt;0.0)||any(hitUV&gt;1.0))
        &#123;
            if(mipLevel==0)
            &#123;
                return float4(col);
            &#125;
            else
            &#123;
                P -= dp * exp2(mipLevel);
                Q -= dq * exp2(mipLevel);
                K -= dk * exp2(mipLevel);
                preZ = Q.z / K;
                mipLevel--;
                break;
            &#125;
        &#125;
        float rawDepth = SAMPLE_TEXTURE2D_X_LOD(_HierarchicalZBufferTexture, sampler_PointClamp, hitUV, mipLevel).r;
        float surfaceDepth = -LinearEyeDepth(rawDepth, _ZBufferParams);
        bool isBehind = rayZMin+0.01 &lt;= surfaceDepth;//防止步进步数过小，自反射；
        if (!isBehind)
        &#123;
            mipLevel = min(mipLevel + 1, _MaxHierarchicalZBufferTextureMipLevel);
        &#125;
        else
        &#123;
            if (mipLevel == 0)
            &#123;
                if (abs(surfaceDepth - rayZMax) &lt; _Thickness)
                    return GetSource(hitUV)+col;
            &#125;
            else
            &#123;
                P -= dp * exp2(mipLevel);
                Q -= dq * exp2(mipLevel);
                K -= dk * exp2(mipLevel);
                preZ = Q.z / K;
                mipLevel--;
            &#125;
        &#125;
    &#125;
    return float4(col);
&#125;
//生成HiZ的深度图用片源着色器
float4 HiZfrag (v2f i) : SV_Target
&#123;
    float2 uv = i.uv;

    float4 minDepth = float4(
        GetHiZSoure(uv, float2(-1, -1), _HierarchicalZBufferTextureFromMipLevel).r,
        GetHiZSoure(uv, float2(-1, 1), _HierarchicalZBufferTextureFromMipLevel).r,
        GetHiZSoure(uv, float2(1, -1), _HierarchicalZBufferTextureFromMipLevel).r,
        GetHiZSoure(uv, float2(1, 1), _HierarchicalZBufferTextureFromMipLevel).r
    );
    float MaxDepth = max(max(minDepth.r, minDepth.g), max(minDepth.b, minDepth.a));
    return MaxDepth;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 枫雪のHome
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;枫雪
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
