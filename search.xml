<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>后处理描边</title>
      <link href="/2025/09/19/%E5%90%8E%E5%A4%84%E7%90%86%E6%8F%8F%E8%BE%B9/"/>
      <url>/2025/09/19/%E5%90%8E%E5%A4%84%E7%90%86%E6%8F%8F%E8%BE%B9/</url>
      
        <content type="html"><![CDATA[<p>本篇是后处理描边的开发日记——挖坑施工中</p><span id="more"></span><h1 id="参考">1.参考</h1><p>模仿对象为虚幻引擎技术分享日中幻塔对场景描边的实现相关链接如下：<ahref="https://www.bilibili.com/video/BV1rW2LYvEox?t=1257.8">用虚幻引擎5为《幻塔》定制高品质动画流程风格化渲染管线</a>。其中有几个技术点:</p><p>1.深度法线描边，根据深度值和法线做相关计算，深度剧烈变化处会被判断为描边</p><p>2.Mesh ID变化处会被检测为描边（这个不太清楚，需要重点查一下）</p><p>3.模仿幻塔的管线，根据场景深度对描边做3等级的区分，使用合适的描边手段，让结果看起来更加自然</p><h1 id="ps.一些小记录">PS.一些小记录</h1><h2id="关于深度图的获取和两个深度图的解码函数">1.关于深度图的获取和两个深度图的解码函数</h2><p>这两个函数分别是</p><p>Linear01Depth(float z)与LinearEyeDepth(floatz)，暂时粗浅的理解：前者的深度值为0~1之间的线性深度值，后者的深度值约等于视空间的z值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多Pass的毛发</title>
      <link href="/2025/07/12/%E5%A4%9APass%E7%9A%84%E6%AF%9B%E5%8F%91/"/>
      <url>/2025/07/12/%E5%A4%9APass%E7%9A%84%E6%AF%9B%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>挖坑施工中</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVP矩阵</title>
      <link href="/2025/07/07/MVP%E7%9F%A9%E9%98%B5/"/>
      <url>/2025/07/07/MVP%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>挖坑施工中（MVP矩阵过于基础和深刻，需要花很长时间将他完善，已完成视图矩阵）——MVP矩阵是渲染中基础中的基础，很多进阶效果都需要对MVP矩阵有深刻的理解，下文将对MVP矩阵进行详细的讲解</p><span id="more"></span><h1 id="mvp矩阵概述">1.MVP矩阵概述</h1><p>模型本质是一堆点坐标的集合，各点的坐标位置就是建模软件中模型的各个顶点坐标，这个阶段的坐标被成为模型空间坐标或者对象空间（ObjectSpace）。我们要做的就是将模型顶点变换到屏幕空间。它将会经历以下过程：<span class="math display">$$\text{模型空间}\xrightarrow{Model（模型矩阵）}\text{世界空间}\xrightarrow{\text{View（观察矩阵）}}\text{视空间}\xrightarrow{\text{Projection（投影矩阵）}}\text{裁剪空间}$$</span></p><h2 id="齐次坐标"><strong>齐次坐标</strong></h2><p>MVP矩阵全部用齐次坐标表示，为了统一纺射变换（平移）与线性变换（旋转和缩放）在图形学中一般使用齐次坐标来表达，我们在原本的3维矩阵中多加一个维度变成4x4的矩阵，这样平移矩阵就也可以像缩放和旋转矩阵一样使用了，矩阵中第四列就是表示的平移量。引入齐次坐标后，我们可以通过第四个分量：w分量，来区分顶点和向量，一般顶点表示为（x，y，z，1）而向量则表示为（x，y，z，0）。这样表示有以下好处：</p><ol type="1"><li>点+向量=点：当顶点和向量相加时表示的是这个顶点向向量方向移动一段距离：对于任意顶点P=（x，y，z，1）我们与任意向量<spanclass="math inline">$\vec{a_1}$</span>=（a，b，c，0）相加所得结果P’=(x+a，y+b，z+c，1+0)，所得结果还是一个顶点。</li><li>向量+向量=向量：当向量与向量相加的时候得到一个新向量，它表示这两个向量的叠加：我们有<spanclass="math inline">$\vec{a_1}=（a_1，b_1，c_1，0）$</span>与<spanclass="math inline">$\vec{a_2}=（a_2，b_2，c_2，0）$</span>相加所得结果<spanclass="math inline">$\vec{a_3}=（a_1+a_2，b_1+b_2，c_1+c_2，0）$</span>它表示的是一个新的向量。</li><li>点-点=向量：A点减B点等于B指向A的一个向量，这个向量的模长就是两点之间的距离：对于点<spanclass="math inline"><em>P</em><sub>1</sub> = （<em>X</em><sub>1</sub>, <em>Y</em><sub>1</sub>, <em>Z</em><sub>1</sub>, 1）</span>，<spanclass="math inline"><em>P</em><sub>2</sub> = （<em>X</em><sub>2</sub>, <em>Y</em><sub>2</sub>, <em>Z</em><sub>2</sub>, 1）</span>当<spanclass="math inline"><em>P</em><sub>1</sub> − <em>P</em><sub>2</sub></span>时得到结果<spanclass="math inline"><em>a⃗</em> = (<em>X</em><sub>1</sub> − <em>X</em><sub>2</sub>, <em>Y</em><sub>1</sub> − <em>Y</em><sub>2</sub>, <em>Z</em><sub>1</sub> − <em>Z</em><sub>2</sub>, 0)</span></li><li>点+点=两点中点：当点与点相加时表示的是这两个点的中点：我们需要引入一个规定，对于所有大于w值大于1的量，我们需要除以w本身才表示原先要表示的量，也就是(x，y，z，w)⇒(x/w，y/w，z/w，1)。对于点<spanclass="math inline"><em>P</em><sub>1</sub> = （<em>x</em><sub>1</sub>，<em>y</em><sub>1</sub>，<em>z</em><sub>1</sub>，1）</span>与<spanclass="math inline"><em>P</em><sub>2</sub> = （<em>x</em><sub>2</sub>，<em>y</em><sub>2</sub>，<em>z</em><sub>2</sub>，1）</span>，<spanclass="math inline"><em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> = (<em>x</em><sub>1</sub> + <em>x</em><sub>2</sub>，<em>y</em><sub>1</sub> + <em>y</em><sub>2</sub>，<em>z</em><sub>1</sub> + <em>z</em><sub>2</sub>，2)</span>实际上表示的值是<spanclass="math inline">$（\frac{x_1+x_2}{2}，\frac{y_1+y_2}{2}，\frac{z_1+z_2}{2}，1）$</span></li></ol><h1 id="m矩阵模型矩阵">2.M矩阵—模型矩阵</h1><p>模型矩阵是为了将模型从模型空间变换到世界空间，可以理解为就是将一个模型拖到untiy的场景中，此时世界空间原点就是unity场景的原点，我们就是要求得模型各个顶点与这个unity场景的原点之间的关系。其实无非就是以下几点：缩放，旋转，平移。</p><h2 id="缩放矩阵">2.1缩放矩阵</h2><p>对于任意顶点P=（x，y，z），我们进行缩放<spanclass="math inline"><em>S</em><sub><em>x</em></sub></span>，<spanclass="math inline"><em>S</em><sub><em>y</em></sub></span>，<spanclass="math inline"><em>S</em><sub><em>z</em></sub></span>只需要将x，y，z各点乘以对应的缩放值就可以了：<spanclass="math inline"><em>S</em><sub><em>m</em></sub> = (<em>x</em> × <em>S</em><sub><em>x</em></sub>, <em>y</em> × <em>S</em><sub><em>y</em></sub>, <em>z</em> × <em>S</em><sub><em>z</em></sub>)</span>，这里<spanclass="math inline"><em>S</em><sub><em>x</em></sub></span>，<spanclass="math inline"><em>S</em><sub><em>y</em></sub></span>，<spanclass="math inline"><em>S</em><sub><em>z</em></sub></span>所对应的就是unity中Transform的缩放的XYZ值。</p><p>写成矩阵形式，缩放矩阵： <span class="math display">$$S_m=\begin{pmatrix}S_x &amp; 0 &amp; 0 &amp;0 \\0 &amp; S_y &amp; 0 &amp;0\\0 &amp; 0 &amp; S_z &amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}x  \\y \\z \\1\end{pmatrix}$$</span> ## 2.2旋转矩阵</p><p>对于旋转矩阵的推导我们可以先考虑二维空间的情况。</p><p>如图所示，我们要将图形进行如下的旋转。（蓝色方块<spanclass="math inline">→</span>红色方块）</p><p><img src="./image-20250727171407324.png" /></p><p>将蓝色方块旋转<spanclass="math inline"><em>θ</em></span>角，点B变换到<spanclass="math inline"><em>B</em><sub>1</sub></span>点，点D变换到<spanclass="math inline"><em>D</em><sub>1</sub></span>点，由非常简单的勾股定理我们可得：<spanclass="math inline"><em>B</em><sub>1</sub> = (<em>S</em><em>i</em><em>n</em><em>θ</em>, <em>C</em><em>o</em><em>s</em><em>θ</em>)</span>，<spanclass="math inline"><em>D</em><sub>1</sub> = (−<em>S</em><em>i</em><em>n</em><em>θ</em>, <em>C</em><em>o</em><em>s</em><em>θ</em>)</span>。</p><p>我们要推导出旋转矩阵，这个矩阵对空间中任意点适用，那么对于点B也同样是适用的，点B的坐标为<spanclass="math inline"><em>B</em> = (1, 0)</span>，那么<spanclass="math inline"><em>B</em><sub>1</sub></span>与B的关系写成矩阵的形式就为：<span class="math display">$$B_1=\begin{pmatrix}a&amp;b\\c&amp;d\\\end{pmatrix}B\Rightarrow\begin{pmatrix}Cos\theta \\Sin\theta\\\end{pmatrix}=\begin{pmatrix}a&amp;b\\c&amp;d\\\end{pmatrix}\begin{pmatrix}1  \\0 \\\end{pmatrix}$$</span>我们求得只要求出abcd也就得到了二维空间下的旋转矩阵。由上面的矩阵我们可以得知：<spanclass="math inline"><em>C</em><em>o</em><em>s</em><em>θ</em> = <em>a</em> ⋅ 1 + <em>b</em> ⋅ 0 = <em>a</em></span>而<spanclass="math inline"><em>S</em><em>i</em><em>n</em><em>θ</em> = <em>c</em> ⋅ 1 + <em>d</em> ⋅ 0 = <em>c</em></span>，由此我们求得<spanclass="math inline"><em>a</em> = <em>C</em><em>o</em><em>s</em><em>θ</em></span>，<spanclass="math inline"><em>c</em> = <em>S</em><em>i</em><em>n</em><em>θ</em></span>。</p><p>同理，我们可以利用D与<spanclass="math inline"><em>D</em><sub>1</sub></span>的关系求得b与d的值，他们分别为：<spanclass="math inline"><em>b</em> = −<em>S</em><em>i</em><em>n</em><em>θ</em></span>，<spanclass="math inline"><em>d</em> = <em>C</em><em>o</em><em>s</em><em>θ</em></span>。</p><p>由此我们就得到了二维空间下的旋转矩阵： <span class="math display">$$R_\theta=\begin{pmatrix}Cos\theta&amp;-Sin\theta\\Sin\theta&amp;Cos\theta\\\end{pmatrix}$$</span>对于三维空间我们有些许不同，如下图所示，对于三维空间我们旋转的方向自由了很多，可以有各种各样的旋转方式。而求得可以实现任意方向旋转的旋转矩阵是非常复杂的。我们姑且可以用一个取巧的方式：先学会各个轴的旋转矩阵，再用各轴旋转来组合成为任意方向的旋转矩阵。</p><p><img src="image-20250727174035493.png" /></p><p>这里先直接给出各个轴的旋转矩阵 <span class="math display">$$R_x(\theta) =\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos\theta &amp; -\sin\theta &amp; 0 \\0 &amp; \sin\theta &amp; \cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\quadR_y(\theta) =\begin{pmatrix}\cos\theta &amp; 0 &amp; \sin\theta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin\theta &amp; 0 &amp; \cos\theta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\quadR_z(\theta) =\begin{pmatrix}\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0 \\\sin\theta &amp; \cos\theta &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}$$</span>我们可以这样理解三维的各轴矩阵：首先，对于各轴的旋转，所对应轴的顶点是没有变化的，所以三个矩阵对应的轴值不变：</p><p><img src="image-20250727175131383.png" /></p><p>而内部，其实就是二维的旋转矩阵，只不过对于Y轴来说情况有点特殊，根据右手螺旋定则：<spanclass="math inline"><em>z</em> = <em>x</em> × <em>y</em></span>，<spanclass="math inline"><em>x</em> = <em>y</em> × <em>z</em></span>，而对于y则有些特殊，<spanclass="math inline"><em>y</em> = <em>z</em> × <em>x</em></span>而不是<spanclass="math inline"><em>y</em> = <em>x</em> × <em>z</em></span>所以y是反过来的，中间的两个sin值对于传统的二维矩阵来说是取负的</p><p>得到各轴的旋转方式之后，我们就可以将旋转进行组合，得到任意方向的旋转<spanclass="math inline"><em>R</em><sub><em>m</em></sub>(<em>α</em>, <em>β</em>, <em>γ</em>) = <em>R</em><sub><em>x</em></sub>(<em>α</em>)<em>R</em><sub><em>y</em></sub>(<em>β</em>)<em>R</em><sub><em>z</em></sub>(<em>γ</em>)</span>用于旋转的四个角就是欧拉角。这三个欧拉角所对应的就是unity中Transform的旋转的XYZ值。</p><h2 id="平移矩阵">2.3平移矩阵</h2><p>平移矩阵最为简单，前面说过，为了统一平移和旋转、缩放矩阵使用齐次坐标，而齐次坐标的最后一列所对应的就是平移矩阵。我们直接给出平移矩阵：<span class="math display">$$T_m=\begin{pmatrix}1 &amp; 0 &amp; 0 &amp;T_x \\0 &amp; 1 &amp; 0 &amp;T_y\\0 &amp; 0 &amp; 1 &amp;T_z\\0&amp;0&amp;0&amp;1\end{pmatrix}$$</span> <spanclass="math inline"><em>T</em><sub><em>x</em></sub></span>，<spanclass="math inline"><em>T</em><sub><em>y</em></sub></span>，<spanclass="math inline"><em>T</em><sub><em>z</em></sub></span>所对应的就是unity中Transform的平移的XYZ值。我们直接将<spanclass="math inline"><em>T</em><sub><em>x</em></sub></span>，<spanclass="math inline"><em>T</em><sub><em>y</em></sub></span>，<spanclass="math inline"><em>T</em><sub><em>z</em></sub></span>分别与点坐标的XYZ相加就好。</p><p>需要注意的是，我们在进行所有变换的时候一定要注意顺序，一定要按照缩放—旋转—平移的顺序来做，否则的话会得到不正确的结果。先旋转再平移和先平移再旋转为例：</p><p><img src="geogebra-export.png" /></p><p>（’与“分别表示第一次变换和第二次变换）</p><p>蓝色为原图形，红色是先旋转再平移后的结果，而绿色则是先平移再旋转的结果，可以看到：绿色的图形先平移之后还以原点为中心进行旋转导致我们得到了错误的结果。</p><p>最后，我们将组合一下模型矩阵：<spanclass="math inline"><em>M</em><sub><em>m</em></sub> = <em>T</em><sub><em>m</em></sub><em>R</em><sub><em>m</em></sub><em>S</em><sub><em>m</em></sub></span></p><h1 id="v矩阵视图矩阵">3.V矩阵—视图矩阵</h1><p>V矩阵的作用是将世界空间中的物体变换到视空间，也就是以摄象机为原点的空间。这里的变换就不涉及缩放，只有平移和旋转操作。接下来是对V矩阵的推导，使用Games101中的办法。</p><p>首先我们需要定义一个摄象机就需要如下属性：位置、朝向、向上方向。位置和朝向很好理解，不同位置，不同朝向的摄象机拍出的画面肯定是不同的，而向上方向则是来确定摄象机拍摄的角度。如下图所示：</p><p><img src="Snipaste_2025-07-28_13-51-07.png" /></p><p>有了摄象机我们就可以拍摄世界空间中的物体了，我们可以将摄象机摆在世界空间的任意位置，然后旋转任意方向来拍摄，然后通过位置和旋转信息来计算V矩阵。但是这样计算比较麻烦，我们可以这样想，如果我们把摄象机摆一个标准位置：既世界空间的原点，镜头朝向-Z，向上方向是Y轴方向，然后移动整个世界空间的物体，让它们同样按照刚才摄象机移动到标准位置的方式移动，这样实际上摄象机与整个场景中的物体相对运动是不变的，拍出来的效果是一样的。所以我们直接求得摄象机向标准位置移动的矩阵，也就顺便求出了整个V矩阵。</p><p>如图所示：我们要将右面的坐标移动到左下面的标准坐标，其中向量<spanclass="math inline"><em>e⃗</em></span>是相机移动的方向，向量<spanclass="math inline"><em>ĝ</em></span>与<spanclass="math inline"><em>t̂</em></span>分别表示摄象机的朝向与向上方向</p><p><img src="Snipaste_2025-07-28_14-17-36.png" /></p><p>第一步很简单，就是直接将摄象机移动到原点，我们只需要将摄象机移动的方向取反就好了：<span class="math display">$$T_v=\begin{pmatrix}1 &amp; 0 &amp; 0 &amp;-x_e \\0 &amp; 1 &amp; 0 &amp;-y_e\\0 &amp; 0 &amp; 1 &amp;-z_e\\0&amp;0&amp;0&amp;1\end{pmatrix}$$</span> 接下来我们要做的是将<spanclass="math inline"><em>ĝ</em></span>旋转到世界空间-z轴方向，将<spanclass="math inline"><em>t̂</em></span>旋转到世界空间Y轴方向。但是这样做比较困难，我们可以先求从-z方向变换到<spanclass="math inline"><em>ĝ</em></span>方向，从y方向变换到<spanclass="math inline"><em>t̂</em></span>方向，x轴变换到<spanclass="math inline"><em>ĝ</em> × <em>t̂</em></span>方向的矩阵，易得：<span class="math display">$$\begin{pmatrix}x_{\hat{g}\times\hat{t}} &amp; x_t &amp; x_{-g} &amp; 0\\y_{\hat{g}\times\hat{t}} &amp; y_t &amp; y_{-g} &amp; 0\\z_{\hat{g}\times\hat{t}} &amp; z_t &amp; z_{-g} &amp; 0\\0&amp;0&amp;0&amp;1\end{pmatrix}$$</span>我们只需要将这个矩阵求个逆变换就可以得到我们需要的矩阵，而旋转矩阵是个正交矩阵，他的转置就等于逆变换，所以我们转置即可得到v矩阵的旋转矩阵：<span class="math display">$$R_v=\begin{pmatrix}x_{\hat{g}\times\hat{t}}&amp;y_{\hat{g}\times\hat{t}}&amp;z_{\hat{g}\times\hat{t}}&amp;0\\x_t&amp;y_t&amp;z_t&amp;0\\x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}$$</span></p><p>这样我们就得到了V矩阵：<spanclass="math inline"><em>M</em><sub><em>v</em></sub> = <em>R</em><sub><em>v</em></sub><em>T</em><sub><em>v</em></sub></span>，也可以将两个矩阵写在一起（当平移矩阵和其他矩阵写在一起的时候视作先进行平移矩阵，在进行其他矩阵）：<span class="math display">$$M_v=\begin{pmatrix}x_{\hat{g}\times\hat{t}}&amp;y_{\hat{g}\times\hat{t}}&amp;z_{\hat{g}\times\hat{t}}&amp;-x_e\\x_t&amp;y_t&amp;z_t&amp;-y_e\\x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;-z_e\\0&amp;0&amp;0&amp;1\end{pmatrix}$$</span>观察这个矩阵我们也可以拿到一些信息：<strong>他的第二行前三个数就是摄象机的向上方向，第三行三个数就是摄象机朝向，最后一列是摄象机的世界空间坐标的反向</strong>，我们就可以通过访问视图矩阵来拿到一些信息来做一些效果。此外，视空间顶点的z值就是这点的深度值，我们可以通过这个方式来计算深度。</p><h1 id="p矩阵投影矩阵">4.P矩阵—投影矩阵</h1><p>在很长一段时间里我都分不清投影矩阵之间的步骤，什么NDC空间、齐次裁剪空间之类的，还会有透视除法之类关系。第一次接触MVP矩阵是跟着闫令其老师的《Games101》，貌似他讲到投影矩阵的时候没有提到这些东西，但是不论是在各类文章中还是在unity引擎中都有频繁提到，其中还涉及到各种深度的问题，这次我将将他一次性理顺。</p><p>投影矩阵分为两种，分别是透视投影和正交投影。透视投影模仿的是现实世界中人的眼睛</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义URP管线的延迟渲染</title>
      <link href="/2025/07/04/%E8%87%AA%E5%AE%9A%E4%B9%89URP%E7%AE%A1%E7%BA%BF%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93/"/>
      <url>/2025/07/04/%E8%87%AA%E5%AE%9A%E4%B9%89URP%E7%AE%A1%E7%BA%BF%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>在看本文章前最好先去了解下延迟渲染的基本原理，甚至修改过老管线的延迟渲染，不然可能有看不懂的地方。</p><p>unity版本：unity2022.3.18.f1</p><span id="more"></span><h2 id="修改管线">1.修改管线</h2><p>由于我们直接修改URP的代码会被自动改回去，为了让我们修改的代码能够保存，我们要将项目文件夹下Library.unity.render-pipelines.universal@14.0.10剪切到项目文件夹下的Packages文件中</p><figure><imgsrc="https://pic3.zhimg.com/v2-516719dabacc80da231d746dec57d59a_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从左边到右边</p><p>如果没什么意外的话再打开untiy的话修改的代码应该就不会再该回去了。</p><h2 id="设置延迟管线">2.设置延迟管线</h2><p>想自定义延迟管线的话第一步当然是先改成延迟管线，我们依次点击Edit-ProjectSettings，在Graphics中应该能看到有个选择当前管线的地方，点一下，就能定位到当前使用的管线。</p><figure><imgsrc="https://pic4.zhimg.com/v2-a42fdb2b35315ce8ce8e568d94248333_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>就是这里</p><p>然后再点击这个管线的RendererList，就能找到修改为延迟管线的地方</p><figure><imgsrc="https://picx.zhimg.com/v2-8dd3596618902ff73bb8891db5d6ac31_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后RenderingPath从Forward改为Deferred</p><figure><imgsrc="https://pic2.zhimg.com/v2-bd386f609edb34736594013a1614867f_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="gbufferpass">3.<ahref="https://zhida.zhihu.com/search?content_id=247600342&amp;content_type=Article&amp;match_order=1&amp;q=GbufferPass&amp;zhida_source=entity">GbufferPass</a></h2><p>总所周知，延迟渲染主要由传递数据的GbufferPass和计算光照的<ahref="https://zhida.zhihu.com/search?content_id=247600342&amp;content_type=Article&amp;match_order=1&amp;q=LightPass&amp;zhida_source=entity">LightPass</a>组成。这里我们先讲GbufferPass。</p><p>untiy没给统一的URPshader模板，这里先给个我的URP模板方便后续更改：</p><div class="sourceCode" id="cb1"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Shader &quot;Gbuffer&quot;</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&#123;</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    Properties</span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">_MainTex</span> <span class="op">(</span>&quot;MainTex&quot;<span class="op">,</span><span class="dv">2</span>D<span class="op">)</span> <span class="op">=</span> &quot;white&quot;<span class="op">&#123;&#125;</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    SubShader</span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        Tags </span><span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            &quot;RenderType&quot;<span class="op">=</span>&quot;Opaque&quot;</span><span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//渲染的pass</span></span><span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        Pass</span><span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            Tags</span><span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                &quot;LightMode&quot;<span class="op">=</span>&quot;UniversalForward&quot;</span><span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            HLSLPROGRAM</span><span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma vertex vert</span></span><span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma fragment frag</span></span><span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> a2v</span><span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                float4 vertex <span class="op">:</span> POSITION<span class="op">;</span></span><span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                float4 uv <span class="op">:</span> TEXCOORD0<span class="op">;</span></span><span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> v2f</span><span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>                float4 posCS <span class="op">:</span> SV_POSITION<span class="op">;</span></span><span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                float2 uv <span class="op">:</span> TEXCOORD<span class="op">;</span></span><span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            <span class="fu">CBUFFER_START</span><span class="op">(</span>UnityPerMaterial<span class="op">)</span></span><span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            float4 _MainTex_ST<span class="op">;</span></span><span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        CBUFFER_END</span><span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="fu">TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">);</span></span><span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span class="fu">SAMPLER</span><span class="op">(</span>sampler_MainTex<span class="op">);</span></span><span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            v2f <span class="fu">vert</span><span class="op">(</span>a2v v<span class="op">)</span></span><span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                v2f o<span class="op">;</span></span><span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                </span><span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>               </span><span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                VertexPositionInputs vertexInput <span class="op">=</span> <span class="fu">GetVertexPositionInputs</span><span class="op">(</span>v<span class="op">.</span><span class="fu">vertex</span><span class="op">.</span><span class="fu">xyz</span><span class="op">);</span></span><span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">posCS</span> <span class="op">=</span> vertexInput<span class="op">.</span><span class="fu">positionCS</span><span class="op">;</span></span><span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">uv</span> <span class="op">=</span> <span class="fu">TRANSFORM_TEX</span><span class="op">(</span>v<span class="op">.</span><span class="fu">uv</span><span class="op">,</span>_MainTex<span class="op">);</span></span><span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                <span class="kw">return</span> o<span class="op">;</span></span><span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>            float4 <span class="fu">frag</span><span class="op">(</span>v2f i<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>       <span class="op">&#123;</span></span><span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>                float4 MainTex <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">,</span> sampler_MainTex<span class="op">,</span> i<span class="op">.</span><span class="fu">uv</span><span class="op">);</span></span><span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="fu">float4</span><span class="op">(</span>MainTex<span class="op">);</span></span><span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>       <span class="op">&#125;</span></span><span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            ENDHLSL</span><span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span> </span><span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div><p>URP会将所有LightMode为UniversalGBuffer的shader作为Gbuffer阶段的shader，所以我们首先修改LightMode</p><figure><imgsrc="https://pica.zhimg.com/v2-3f2b78d376806d1e291dd76f2fa4ea48_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>总所周知：Gbuffer有4个，分别输出不同的信息用于后续的光照计算，我们创建个结构体，用于输出4个Gbuffer</p><div class="sourceCode" id="cb2"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//将Gubffer打包成结构体输出</span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> DeferredOutPut<span class="op">&#123;</span></span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer0 <span class="op">:</span> SV_TARGET0<span class="op">;</span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer1 <span class="op">:</span> SV_TARGET1<span class="op">;</span></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer2 <span class="op">:</span> SV_TARGET2<span class="op">;</span></span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer3 <span class="op">:</span> SV_TARGET3<span class="op">;</span></span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span></code></pre></div><p>然后我们相应的修改我们的片源着色器，这里我只是往4个Buffer中塞了一堆1</p><div class="sourceCode" id="cb3"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>            DeferredOutPut <span class="fu">frag</span><span class="op">(</span>v2f i<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">&#123;</span></span><span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        DeferredOutPut g<span class="op">;</span></span><span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                <span class="co">//贴图采样</span></span><span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                float4 MainTex <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">,</span> sampler_MainTex<span class="op">,</span> i<span class="op">.</span><span class="fu">uv</span><span class="op">);</span></span><span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer0</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer1</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer2</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer3</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> g<span class="op">;</span></span><span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>     <span class="op">&#125;</span></span></code></pre></div><p>这四个Buffer官方给的精度各不相同，用于应对不同的数据，官方的做法是Gbuffer0：RGB漫反射，A：材质ID？（不确定，不懂是干什么用的），Gbuffer1：RGB高光，A：AO，Gbuffer2：RGB法线，A：光滑度，Gbuffer3：RGB环境光和自发光，A：无（是个1）。</p><figure><imgsrc="https://picx.zhimg.com/v2-cda10c00dea630f9f06268a80c3615a7_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>官方的输出</p><p>我们可以在FrameDebugger中看到它们各自的精度：</p><figure><imgsrc="https://pic2.zhimg.com/v2-e1c57a1a17d0befb752fd478bf9a9117_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Gbuffer0</p><figure><imgsrc="https://pic4.zhimg.com/v2-2ae8726950e8176bda68f44d2b33a935_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Gbuffer1</p><figure><imgsrc="https://picx.zhimg.com/v2-6dd1d116130b2ee343f21813ae2faf4f_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Gbuffer2</p><figure><imgsrc="https://picx.zhimg.com/v2-75fa58529419d89add7dc28fa977af1b_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Gbuffer3</p><p>可以看到Gbuffer3的精度给的最高，因为他考虑到环境光和自发光可能需要HDR，并且没A通道，所以想往A通道塞东西得改代码（后面会说）。</p><p>完整的Gbuffer部分：</p><div class="sourceCode" id="cb4"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Shader &quot;Gbuffer&quot;</span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">&#123;</span></span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Properties</span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">_MainTex</span> <span class="op">(</span>&quot;MainTex&quot;<span class="op">,</span><span class="dv">2</span>D<span class="op">)</span> <span class="op">=</span> &quot;white&quot;<span class="op">&#123;&#125;</span></span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    SubShader</span><span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        Tags </span><span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            &quot;RenderType&quot;<span class="op">=</span>&quot;Opaque&quot;</span><span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//渲染的pass</span></span><span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        Pass</span><span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            Tags</span><span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                &quot;LightMode&quot;<span class="op">=</span>&quot;UniversalGBuffer&quot;</span><span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            HLSLPROGRAM</span><span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma vertex vert</span></span><span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma fragment frag</span></span><span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span><span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> a2v</span><span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                float4 vertex <span class="op">:</span> POSITION<span class="op">;</span></span><span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                float4 uv <span class="op">:</span> TEXCOORD0<span class="op">;</span></span><span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> v2f</span><span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                float4 posCS <span class="op">:</span> SV_POSITION<span class="op">;</span></span><span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                float2 uv <span class="op">:</span> TEXCOORD<span class="op">;</span></span><span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">//将Gubffer打包成结构体输出</span></span><span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> DeferredOutPut<span class="op">&#123;</span></span><span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer0 <span class="op">:</span> SV_TARGET0<span class="op">;</span></span><span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer1 <span class="op">:</span> SV_TARGET1<span class="op">;</span></span><span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer2 <span class="op">:</span> SV_TARGET2<span class="op">;</span></span><span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer3 <span class="op">:</span> SV_TARGET3<span class="op">;</span></span><span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a></span><span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>            <span class="fu">CBUFFER_START</span><span class="op">(</span>UnityPerMaterial<span class="op">)</span></span><span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>            float4 _MainTex_ST<span class="op">;</span></span><span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span><span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        CBUFFER_END</span><span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>            <span class="fu">TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">);</span><span class="co">//在CG中会写成sampler2D _MainTex;</span></span><span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>            <span class="fu">SAMPLER</span><span class="op">(</span>sampler_MainTex<span class="op">);</span></span><span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span><span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a></span><span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>            v2f <span class="fu">vert</span><span class="op">(</span>a2v v<span class="op">)</span></span><span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>                v2f o<span class="op">;</span></span><span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>                </span><span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>                <span class="co">//URP获得裁剪和世界空间顶点</span></span><span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>                VertexPositionInputs vertexInput <span class="op">=</span> <span class="fu">GetVertexPositionInputs</span><span class="op">(</span>v<span class="op">.</span><span class="fu">vertex</span><span class="op">.</span><span class="fu">xyz</span><span class="op">);</span></span><span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">posCS</span> <span class="op">=</span> vertexInput<span class="op">.</span><span class="fu">positionCS</span><span class="op">;</span></span><span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">uv</span> <span class="op">=</span> <span class="fu">TRANSFORM_TEX</span><span class="op">(</span>v<span class="op">.</span><span class="fu">uv</span><span class="op">,</span>_MainTex<span class="op">);</span></span><span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>                <span class="kw">return</span> o<span class="op">;</span></span><span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>            <span class="co">//片源着色器</span></span><span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>            DeferredOutPut <span class="fu">frag</span><span class="op">(</span>v2f i<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>        DeferredOutPut g<span class="op">;</span></span><span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>                <span class="co">//贴图采样</span></span><span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>                float4 MainTex <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">,</span> sampler_MainTex<span class="op">,</span> i<span class="op">.</span><span class="fu">uv</span><span class="op">);</span></span><span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer0</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer1</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer2</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer3</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> g<span class="op">;</span></span><span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>         <span class="op">&#125;</span></span><span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>            ENDHLSL</span><span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div><h2 id="lightpass">4.LightPass</h2><p>老的渲染管线可以自己写个LightPass然后在untiy中直接替换，但URP中却不能用这样的方式，所以我们直接去修改URP的shader（其实是有别的方式，可以用自己的shader，但我不会）。</p><p>我们去翻FrameDebugger，直接打开URP的LightPass</p><figure><imgsrc="https://pic2.zhimg.com/v2-a55ec232c61700d6964ef9182bb9eb75_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>直接点那个shader就能定位到位置</p><p>他是一个700多行的shader，挺多，别慌，其实untiy用到的就是其中的一两个Pass，也就是3，4Pass，这点也可以在FrameDebugger中看到：</p><figure><imgsrc="https://pic4.zhimg.com/v2-1cfa5b1a2109998748cc0dff6d24b9a5_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>URP所使用的Pass</p><p>我们打开那个shader看看这俩pass分别写了什么：</p><figure><imgsrc="https://pic4.zhimg.com/v2-614bf4388f77385295225598de3f6f8d_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://pic1.zhimg.com/v2-3e285dcc38e15de599ed346636cb101e_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>关键在于红框的位置，注释部分标明了这个pass的用途，下面则写了他所使用的顶点片源着色器，这两个pass所使用的片源着色器是相同的，这就方便了我们的修改，我们的目的正是修改片源着色器的部分</p><figure><imgsrc="https://picx.zhimg.com/v2-4a75f4b665da8e9a976777e710c97cdf_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>URP的片源着色器部分</p><figure><imgsrc="https://pic2.zhimg.com/v2-8dd35308d5c1eedcb9cf977095f16ec7_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>接上图</p><figure><imgsrc="https://pica.zhimg.com/v2-52418289d6beca87d1b5dc6bfcc4c162_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>接上图</p><p>其中有各种乱七八糟的宏来定义各种情况，咱不用管，关键在于两个地方：其一是采样Gbuffer的方式，我们可以直接用URP的</p><figure><imgsrc="https://pic2.zhimg.com/v2-9f380795257610956a5bec27ef33508f_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里是3个Gbuffer和一个深度</p><p>可以看到unity只采样了前3个buffer，而gbuffer3却没有采样。这是因为unity会自动将gbuffer3给加到最后的return中，这点需要注意，我们在计算的过程中别再加一遍gbuffer3的数值了，也意味着gbuffer3只能存一些能直接加的东西，一些花里胡哨的东西就别往gbuffer3里存了。</p><p>第二个关键点在于深度图重构世界坐标的方式，我们可以直接用unity的方式：</p><figure><imgsrc="https://pic2.zhimg.com/v2-d7ab327ed5d028844f4a60664a1f15e5_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>深度图重构世界坐标</p><p>其中eyeIndex是关于适配xr的，我们不去管xr，直接把eyeIndex改成0，他是我们正常使用的矩阵</p><p>剩下的地方咱删了自己写：</p><div class="sourceCode" id="cb5"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    half4 <span class="fu">DeferredShading</span><span class="op">(</span>Varyings input<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span><span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        float2 screen_uv <span class="op">=</span> <span class="op">(</span>input<span class="op">.</span><span class="fu">screenUV</span><span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> input<span class="op">.</span><span class="fu">screenUV</span><span class="op">.</span><span class="fu">z</span><span class="op">);</span></span><span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        </span><span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> d        <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_CameraDepthTexture<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">).</span><span class="fu">x</span><span class="op">;</span> <span class="co">// raw depth value has UNITY_REVERSED_Z applied on most platforms.</span></span><span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer0 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer0<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer1 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer1<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer2 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer2<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        </span><span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        float4 posWS <span class="op">=</span> <span class="fu">mul</span><span class="op">(</span>_ScreenToWorld<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="fu">float4</span><span class="op">(</span>input<span class="op">.</span><span class="fu">positionCS</span><span class="op">.</span><span class="fu">xy</span><span class="op">,</span> d<span class="op">,</span> <span class="fl">1.0</span><span class="op">));</span></span><span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        posWS<span class="op">.</span><span class="fu">xyz</span> <span class="op">*=</span> <span class="fu">rcp</span><span class="op">(</span>posWS<span class="op">.</span><span class="fu">w</span><span class="op">);</span></span><span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span><span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        </span><span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span><span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="fu">half4</span><span class="op">(</span>gbuffer0<span class="op">.</span><span class="fu">rgb</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span><span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span></code></pre></div><p>这里我直接将gbuffer0的rgb输出来看结果，我将GbufferPass的gbuffer0输出改为MainTex，并且把Gbuffer3的值改为了0（防止unity直接将gbuffer3加上去影响对结果的判断）</p><figure><imgsrc="https://pic1.zhimg.com/v2-776fc0cc68617fb0b973268bf5ef1d1c_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>加了贴图的结果</p><h2 id="法线">5.法线</h2><p>由于法线是-1<sub>1的数据，而Gbuffer是0</sub>1的数据，所以我们需要在Gbuffer阶段编码一下，再到LightPass阶段解码一下。</p><div class="sourceCode" id="cb6"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//在GbufferPass</span></span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>float3 nDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>i<span class="op">.</span><span class="fu">nDirWS</span><span class="op">)*</span><span class="fl">0.5+0.5</span><span class="op">;</span></span><span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>g<span class="op">.</span><span class="fu">gBuffer2</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span>nDirWS<span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><div class="sourceCode" id="cb7"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">//在LightPass</span></span><span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>float3 nDirWS <span class="op">=</span> gbuffer2<span class="op">.</span><span class="fu">rgb</span><span class="op">*</span><span class="dv">2-1</span><span class="op">;</span></span></code></pre></div><p>但是这种方式所得的结果法线精度会有不够的问题，计算兰伯特的时候会导致结果很丑：</p><figure><imgsrc="https://pic3.zhimg.com/v2-ae1c21e1e67f81a011b2e5ddfcec3ce6_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>兰伯特结果</p><figure><imgsrc="https://pic1.zhimg.com/v2-9767e8a4f5b62dc99e706fe0679fb808_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>半兰伯特结果</p><p>unity中有个设置，可以提高法线精度</p><figure><imgsrc="https://pic1.zhimg.com/v2-e92eed18f946368298f3a2b3f2978ffc_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>就是这个选项</p><p>打开它，untiy会改变Gbuffer2的rt格式并且使用八面体映射的方式来进行编码法线（前提是你解码法线和编码法线是用的unity的函数）</p><figure><imgsrc="https://pic4.zhimg.com/v2-7686575122c00e91dad0ed8da4d051c3_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>使用高精度法线后的rt格式</p><figure><imgsrc="https://pic1.zhimg.com/v2-80e42a9a7d8f68be3a6173f3b17c2238_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>使用八面体映射编码后的法线（未解码）</p><p>这里我直接把unity八面体映射的编码和解码方式给搬过来：</p><div class="sourceCode" id="cb8"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">//在GbufferPass（写在片源着色器前面）</span></span><span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">//八面体映射压缩法线，解决法线精度问题</span></span><span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>half3 <span class="fu">EyPackNormal</span><span class="op">(</span>half3 n<span class="op">)</span></span><span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">&#123;</span></span><span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>     float2 octNormalWS <span class="op">=</span> <span class="fu">PackNormalOctQuadEncode</span><span class="op">(</span>n<span class="op">);</span>                  <span class="co">// values between [-1, +1], must use fp32 on some platforms.</span></span><span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>     float2 remappedOctNormalWS <span class="op">=</span> <span class="fu">saturate</span><span class="op">(</span>octNormalWS <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">);</span>   <span class="co">// values between [ 0, +1]</span></span><span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>     <span class="kw">return</span> <span class="fu">half3</span><span class="op">(</span><span class="fu">PackFloat2To888</span><span class="op">(</span>remappedOctNormalWS<span class="op">));</span>               <span class="co">// values between [ 0, +1]</span></span><span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span><span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">//Gbufferpass的片源着色器中</span></span><span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>float3 nDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>i<span class="op">.</span><span class="fu">nDirWS</span><span class="op">);</span></span><span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>nDirWS <span class="op">=</span> <span class="fu">EyPackNormal</span><span class="op">(</span>nDirWS<span class="op">);</span></span><span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>g<span class="op">.</span><span class="fu">gBuffer2</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span>nDirWS<span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><div class="sourceCode" id="cb9"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">//LightPass的片源着色器前面</span></span><span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">//解码八面体映射的法线</span></span><span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    half3 <span class="fu">EyUnpackNormal</span><span class="op">(</span>half3 pn<span class="op">)</span></span><span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        half2 remappedOctNormalWS <span class="op">=</span> <span class="fu">half2</span><span class="op">(</span><span class="fu">Unpack888ToFloat2</span><span class="op">(</span>pn<span class="op">));</span>          <span class="co">// values between [ 0, +1]</span></span><span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        half2 octNormalWS <span class="op">=</span> remappedOctNormalWS<span class="op">.</span><span class="fu">xy</span> <span class="op">*</span> <span class="fu">half</span><span class="op">(</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">-</span> <span class="fu">half</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span><span class="co">// values between [-1, +1]</span></span><span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="fu">half3</span><span class="op">(</span><span class="fu">UnpackNormalOctQuadEncode</span><span class="op">(</span>octNormalWS<span class="op">));</span>              <span class="co">// values between [-1, +1]</span></span><span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span></code></pre></div><div class="sourceCode" id="cb10"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">//在LightPass 的片源着色器里面</span></span><span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>float3 nDirWS <span class="op">=</span> gbuffer2<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span></span><span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>nDirWS <span class="op">=</span> <span class="fu">EyUnpackNormal</span><span class="op">(</span>nDirWS<span class="op">);</span></span></code></pre></div><p>这样之后法线精度就差不多了：</p><figure><imgsrc="https://pic3.zhimg.com/v2-4d61b373c5ddb5da7fff196b00dbe04c_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>处理法线之后的半兰伯特</p><p>GbufferPass的完整代码如下</p><div class="sourceCode" id="cb11"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Shader &quot;Gbuffer&quot;</span><span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">&#123;</span></span><span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    Properties</span><span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">_MainTex</span> <span class="op">(</span>&quot;MainTex&quot;<span class="op">,</span><span class="dv">2</span>D<span class="op">)</span> <span class="op">=</span> &quot;white&quot;<span class="op">&#123;&#125;</span></span><span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    SubShader</span><span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        Tags </span><span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            &quot;RenderType&quot;<span class="op">=</span>&quot;Opaque&quot;</span><span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//渲染的pass</span></span><span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        Pass</span><span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            Tags</span><span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                &quot;LightMode&quot;<span class="op">=</span>&quot;UniversalGBuffer&quot;</span><span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            HLSLPROGRAM</span><span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma vertex vert</span></span><span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#pragma fragment frag</span></span><span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span><span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> a2v</span><span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>                float4 vertex <span class="op">:</span> POSITION<span class="op">;</span></span><span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>                float4 uv <span class="op">:</span> TEXCOORD0<span class="op">;</span></span><span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>                float3 normal <span class="op">:</span> NORMAL<span class="op">;</span></span><span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> v2f</span><span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>                float4 posCS <span class="op">:</span> SV_POSITION<span class="op">;</span></span><span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>                float2 uv <span class="op">:</span> TEXCOORD<span class="op">;</span></span><span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>                float3 nDirWS <span class="op">:</span> TEXCOORD1<span class="op">;</span></span><span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">//将Gubffer打包成结构体输出</span></span><span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> DeferredOutPut<span class="op">&#123;</span></span><span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer0 <span class="op">:</span> SV_TARGET0<span class="op">;</span></span><span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer1 <span class="op">:</span> SV_TARGET1<span class="op">;</span></span><span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer2 <span class="op">:</span> SV_TARGET2<span class="op">;</span></span><span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>                float4 gBuffer3 <span class="op">:</span> SV_TARGET3<span class="op">;</span></span><span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;;</span></span><span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a></span><span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>            <span class="fu">CBUFFER_START</span><span class="op">(</span>UnityPerMaterial<span class="op">)</span></span><span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>            float4 _MainTex_ST<span class="op">;</span></span><span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span><span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>            CBUFFER_END</span><span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>            <span class="fu">TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">);</span><span class="co">//在CG中会写成sampler2D _MainTex;</span></span><span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>            <span class="fu">SAMPLER</span><span class="op">(</span>sampler_MainTex<span class="op">);</span></span><span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a></span><span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a></span><span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>            v2f <span class="fu">vert</span><span class="op">(</span>a2v v<span class="op">)</span></span><span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>                v2f o<span class="op">;</span></span><span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>                </span><span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>                <span class="co">//URP获得裁剪和世界空间顶点</span></span><span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>                VertexPositionInputs vertexInput <span class="op">=</span> <span class="fu">GetVertexPositionInputs</span><span class="op">(</span>v<span class="op">.</span><span class="fu">vertex</span><span class="op">.</span><span class="fu">xyz</span><span class="op">);</span></span><span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">posCS</span> <span class="op">=</span> vertexInput<span class="op">.</span><span class="fu">positionCS</span><span class="op">;</span></span><span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">uv</span> <span class="op">=</span> <span class="fu">TRANSFORM_TEX</span><span class="op">(</span>v<span class="op">.</span><span class="fu">uv</span><span class="op">,</span>_MainTex<span class="op">);</span></span><span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>                o<span class="op">.</span><span class="fu">nDirWS</span> <span class="op">=</span> <span class="fu">TransformObjectToWorldNormal</span><span class="op">(</span>v<span class="op">.</span><span class="fu">normal</span><span class="op">.</span><span class="fu">xyz</span><span class="op">)</span> <span class="op">;</span></span><span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>                <span class="kw">return</span> o<span class="op">;</span></span><span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>            <span class="co">//八面体映射压缩法线，解决法线精度问题</span></span><span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>            half3 <span class="fu">EyPackNormal</span><span class="op">(</span>half3 n<span class="op">)</span></span><span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#123;</span></span><span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>                float2 octNormalWS <span class="op">=</span> <span class="fu">PackNormalOctQuadEncode</span><span class="op">(</span>n<span class="op">);</span>                  <span class="co">// values between [-1, +1], must use fp32 on some platforms.</span></span><span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>                float2 remappedOctNormalWS <span class="op">=</span> <span class="fu">saturate</span><span class="op">(</span>octNormalWS <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">);</span>   <span class="co">// values between [ 0, +1]</span></span><span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>                <span class="kw">return</span> <span class="fu">half3</span><span class="op">(</span><span class="fu">PackFloat2To888</span><span class="op">(</span>remappedOctNormalWS<span class="op">));</span>               <span class="co">// values between [ 0, +1]</span></span><span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span><span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>            <span class="co">//片源着色器</span></span><span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>            DeferredOutPut <span class="fu">frag</span><span class="op">(</span>v2f i<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#123;</span></span><span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>            DeferredOutPut g<span class="op">;</span></span><span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>        <span class="co">//取数据</span></span><span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>        float3 nDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>i<span class="op">.</span><span class="fu">nDirWS</span><span class="op">);</span></span><span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>                <span class="co">//贴图采样</span></span><span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>                float4 MainTex <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D</span><span class="op">(</span>_MainTex<span class="op">,</span> sampler_MainTex<span class="op">,</span> i<span class="op">.</span><span class="fu">uv</span><span class="op">);</span></span><span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>        nDirWS <span class="op">=</span> <span class="fu">EyPackNormal</span><span class="op">(</span>nDirWS<span class="op">);</span></span><span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer0</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span>MainTex<span class="op">.</span><span class="fu">rgb</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer1</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer2</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span>nDirWS<span class="op">,</span><span class="fl">1.0</span><span class="op">);</span></span><span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">gBuffer3</span> <span class="op">=</span> <span class="fu">float4</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span><span class="fl">0.0</span><span class="op">,</span><span class="fl">0.0</span><span class="op">,</span><span class="fl">0.0</span><span class="op">);</span></span><span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> g<span class="op">;</span></span><span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>         <span class="op">&#125;</span></span><span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>            ENDHLSL</span><span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div><p>LightPass部分代码如下：</p><div class="sourceCode" id="cb12"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//解码八面体映射的法线</span></span><span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    half3 <span class="fu">EyUnpackNormal</span><span class="op">(</span>half3 pn<span class="op">)</span></span><span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        half2 remappedOctNormalWS <span class="op">=</span> <span class="fu">half2</span><span class="op">(</span><span class="fu">Unpack888ToFloat2</span><span class="op">(</span>pn<span class="op">));</span>          <span class="co">// values between [ 0, +1]</span></span><span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        half2 octNormalWS <span class="op">=</span> remappedOctNormalWS<span class="op">.</span><span class="fu">xy</span> <span class="op">*</span> <span class="fu">half</span><span class="op">(</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">-</span> <span class="fu">half</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span><span class="co">// values between [-1, +1]</span></span><span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="fu">half3</span><span class="op">(</span><span class="fu">UnpackNormalOctQuadEncode</span><span class="op">(</span>octNormalWS<span class="op">));</span>              <span class="co">// values between [-1, +1]</span></span><span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    half4 <span class="fu">DeferredShading</span><span class="op">(</span>Varyings input<span class="op">)</span> <span class="op">:</span> SV_Target</span><span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#123;</span></span><span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span><span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        float2 screen_uv <span class="op">=</span> <span class="op">(</span>input<span class="op">.</span><span class="fu">screenUV</span><span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> input<span class="op">.</span><span class="fu">screenUV</span><span class="op">.</span><span class="fu">z</span><span class="op">);</span></span><span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        </span><span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> d        <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_CameraDepthTexture<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">).</span><span class="fu">x</span><span class="op">;</span> <span class="co">// raw depth value has UNITY_REVERSED_Z applied on most platforms.</span></span><span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer0 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer0<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer1 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer1<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        half4 gbuffer2 <span class="op">=</span> <span class="fu">SAMPLE_TEXTURE2D_X_LOD</span><span class="op">(</span>_GBuffer2<span class="op">,</span> my_point_clamp_sampler<span class="op">,</span> screen_uv<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span><span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span><span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//拿数据</span></span><span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        float3 nDirWS <span class="op">=</span> gbuffer2<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span></span><span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        nDirWS <span class="op">=</span> <span class="fu">EyUnpackNormal</span><span class="op">(</span>nDirWS<span class="op">);</span></span><span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        float4 posWS <span class="op">=</span> <span class="fu">mul</span><span class="op">(</span>_ScreenToWorld<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="fu">float4</span><span class="op">(</span>input<span class="op">.</span><span class="fu">positionCS</span><span class="op">.</span><span class="fu">xy</span><span class="op">,</span> d<span class="op">,</span> <span class="fl">1.0</span><span class="op">));</span></span><span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        posWS<span class="op">.</span><span class="fu">xyz</span> <span class="op">*=</span> <span class="fu">rcp</span><span class="op">(</span>posWS<span class="op">.</span><span class="fu">w</span><span class="op">);</span></span><span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        float3 color <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span><span class="fu">float3</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">),</span>nDirWS<span class="op">)*</span><span class="fl">0.5+0.5</span><span class="op">;</span></span><span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="fu">half4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span><span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span></code></pre></div><p><ahref="https://zhuanlan.zhihu.com/p/33905696">这里贴个八面体映射的原理想了解可以去看看</a></p><h2 id="光照">6.光照</h2><p>有了法线我们终于可以计算光照，首先是如何区分平行光和其他光。</p><p>URP是用一个宏来区分的：</p><div class="sourceCode" id="cb13"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(_DIRECTIONAL)</span></span><span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span><span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span><span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span><span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div><p>if后面为平行光照，else后面为其他光源</p><p>先说平行光照。平行光照主要是需要它的方向、颜色（强度被包含在了颜色里），没什么好说的，用的话直接用下面的方法拿就行</p><div class="sourceCode" id="cb14"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">//计算光照</span></span><span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined(_DIRECTIONAL)</span></span><span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>float3 lDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span> _MainLightPosition<span class="op">.</span><span class="fu">xyz</span><span class="op">);</span></span><span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>float3 lightColor <span class="op">=</span> _MainLightColor<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span></span><span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span><span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span><span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div><p>然后是其他光源，主要是点光源和聚光灯。我这里完全没考虑聚光灯，只写了点光源相关，所以如果用了聚光灯的话结果可能会有些奇怪</p><p>对于点光源考虑的就多了：点光源的位置，光照方向，光照的衰减，颜色（强度也是被包含在颜色里了）</p><p>位置和颜色可以直接拿到：</p><div class="sourceCode" id="cb15"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>        float3 lightWS <span class="op">=</span> _LightPosWS<span class="op">;</span><span class="co">//点光源的位置</span></span><span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        float3 lightColor <span class="op">=</span> _LightColor<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span><span class="co">//颜色</span></span></code></pre></div><p>光照方向的话就是点光源位置减去模型的顶点位置（记得归一化）</p><div class="sourceCode" id="cb16"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>        float3 lightWS <span class="op">=</span> _LightPosWS<span class="op">;</span><span class="co">//点光源的位置</span></span><span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        float3 lightColor <span class="op">=</span> _LightColor<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span><span class="co">//颜色</span></span><span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">//计算光照方向</span></span><span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        float3 lightVector <span class="op">=</span> lightWS <span class="op">-</span> posWS<span class="op">.</span><span class="fu">xyz</span><span class="op">;</span></span><span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        float3 lDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lightVector<span class="op">);</span></span></code></pre></div><p>光照衰减：这里直接照搬unity的光照衰减。</p><p>原理的话可以看这篇文章：<ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_51603875/article/details/135847544">Unity中URP下额外灯的距离衰减_distanceattenuation-CSDN博客</a></p><div class="sourceCode" id="cb17"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">//计算衰减（暂时不管聚光灯）</span></span><span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> distanceSqr <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>lightVector<span class="op">,</span> lightVector<span class="op">),</span> HALF_MIN<span class="op">);</span><span class="co">//防止取0</span></span><span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        float4 attenuation <span class="op">=</span> _LightAttenuation<span class="op">;</span></span><span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> lightAtten <span class="op">=</span> <span class="fu">rcp</span><span class="op">(</span>distanceSqr<span class="op">);</span></span><span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        float2 distanceAttenuationFloat <span class="op">=</span> <span class="fu">float2</span><span class="op">(</span>attenuation<span class="op">.</span><span class="fu">xy</span><span class="op">);</span></span><span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        half factor <span class="op">=</span> <span class="fu">half</span><span class="op">(</span>distanceSqr <span class="op">*</span> distanceAttenuationFloat<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span><span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        half smoothFactor <span class="op">=</span> <span class="fu">saturate</span><span class="op">(</span><span class="fu">half</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">-</span> factor <span class="op">*</span> factor<span class="op">);</span></span><span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        smoothFactor <span class="op">=</span> smoothFactor <span class="op">*</span> smoothFactor<span class="op">;</span></span><span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> distanceAttenuation <span class="op">=</span> lightAtten <span class="op">*</span> smoothFactor<span class="op">;</span></span></code></pre></div><p>相关部分完整代码：</p><div class="sourceCode" id="cb18"><preclass="sourceCode glsl"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">//计算光照</span></span><span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#if defined(_DIRECTIONAL)</span></span><span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        float3 lDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span> _MainLightPosition<span class="op">.</span><span class="fu">xyz</span><span class="op">);</span></span><span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        float3 lightColor <span class="op">=</span> _MainLightColor<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span></span><span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> lightColor<span class="op">;</span></span><span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#else</span></span><span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        float3 lightWS <span class="op">=</span> _LightPosWS<span class="op">;</span><span class="co">//点光源的位置</span></span><span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        float3 lightColor <span class="op">=</span> _LightColor<span class="op">.</span><span class="fu">rgb</span><span class="op">;</span><span class="co">//颜色</span></span><span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//计算光照方向</span></span><span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        float3 lightVector <span class="op">=</span> lightWS <span class="op">-</span> posWS<span class="op">.</span><span class="fu">xyz</span><span class="op">;</span></span><span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        float3 lDirWS <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span>lightVector<span class="op">);</span></span><span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//计算衰减（暂时不管聚光灯）</span></span><span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> distanceSqr <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>lightVector<span class="op">,</span> lightVector<span class="op">),</span> HALF_MIN<span class="op">);</span><span class="co">//防止取0</span></span><span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        float4 attenuation <span class="op">=</span> _LightAttenuation<span class="op">;</span></span><span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> lightAtten <span class="op">=</span> <span class="fu">rcp</span><span class="op">(</span>distanceSqr<span class="op">);</span></span><span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        float2 distanceAttenuationFloat <span class="op">=</span> <span class="fu">float2</span><span class="op">(</span>attenuation<span class="op">.</span><span class="fu">xy</span><span class="op">);</span></span><span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        half factor <span class="op">=</span> <span class="fu">half</span><span class="op">(</span>distanceSqr <span class="op">*</span> distanceAttenuationFloat<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span><span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        half smoothFactor <span class="op">=</span> <span class="fu">saturate</span><span class="op">(</span><span class="fu">half</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">-</span> factor <span class="op">*</span> factor<span class="op">);</span></span><span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        smoothFactor <span class="op">=</span> smoothFactor <span class="op">*</span> smoothFactor<span class="op">;</span></span><span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> distanceAttenuation <span class="op">=</span> lightAtten <span class="op">*</span> smoothFactor<span class="op">;</span></span><span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#endif</span></span></code></pre></div><p>这里只是拿到各种光照相关数据，具体的光照计算可以根据自己的需求去实现</p><h2 id="修改rt">7.修改RT</h2><p>有时候URPGbuffer的RT格式不能满足自己的需求，例如这里我用gbuffer2的a通道来传递半兰伯特的结果精度会很差（为什么R8G8B8A8_UNorm还会这么差）：</p><figure><imgsrc="https://pic4.zhimg.com/v2-1db1be7cf0d0bd0f0ccf2d9c1e374397_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>将半兰伯特塞到Gbuffer2的A通道</p><figure><imgsrc="https://picx.zhimg.com/v2-7742e052ded4489d9206ee64c27e4f29_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>结果</p><p>这就需要我们自己去修改RT的格式。</p><p>Gbuffer的RT格式是在DeferredLights.cs的GetGBufferFormat函数中定义的（我这里是第149行），我这里将Gbuffer2的RT直接改为R16G16B16A16_SFloat</p><figure><imgsrc="https://pic1.zhimg.com/v2-697fcd453570192be1eeea667054feba_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从上半部分可以看到之前法线精度开关在RT部分的实际用途</p><figure><imgsrc="https://pic1.zhimg.com/v2-828de6fdb9776d683229c342d1b4acc4_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://pic1.zhimg.com/v2-2ebe8c8a4662d36d5f488568b654d53e_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>修改后的结果</p><p>这里只是举个范例，如果需要其他的修改直接改对应的Gbuffer就行</p><h2 id="在lightpass中插入自己的贴图">8.在LightPass中插入自己的贴图</h2><p>如果做卡通渲染之类可能需要往LightPass中塞ramp贴图，他也在DeferredLights.cs中实现，先在ShaderConstants类中写一个PropertyToID</p><figure><imgsrc="https://pica.zhimg.com/v2-01d0e85492087016582cae59109bffc2_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后在RenderStencilDirectionalLights函数的某for循环中（看图）SetGlobalTexture就行了</p><figure><imgsrc="https://pic2.zhimg.com/v2-f1ef3570bb7ea341ddc277dcf5641dc7_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后就是在LightPass的shader中先声明一下（大概150行左右就能找到untiy声明变量的位置）</p><figure><imgsrc="https://pica.zhimg.com/v2-faf8ab905a6ebc7ba082dadebf20ed70_1440w.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这声明</p><p>然后采样这个贴图的话就正常用SAMPLE_TEXTURE2D采样就行，没什么好说的</p><p>想要加一些贴图以外的变量也是类似的方式，这里就不讲了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 延迟管线 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
